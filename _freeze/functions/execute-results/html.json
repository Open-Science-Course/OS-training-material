{
  "hash": "582e47c58eccef3c23e88b750ca97b49",
  "result": {
    "markdown": "---\ntitle: \"Writing Functions in R\"\nsubtitle: \"Open transparent and reproducible science\"\nauthor: \"Richard J Telford\"\ninstitute: \"University of Bergen\"\nformat: revealjs\neditor: visual\nexecute: \n  echo: true\n---\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n\n\n# Are your R skills sufficient? \n\n\n\n---\n::: r-fit-text\nCan you spell\\\n~~funktion~~ ~~FUNkshun~~\\\nfunction?\n:::\n\n## Don't worry if you cannot\n\n::: r-fit-text\nYou can\\\nuse a \\\\ instead\n:::\n\n## My ~~first~~ worst function\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(){}\nf()\n```\n:::\n\nTakes no arguments. Does not work. Returns nothing.\n\nGuaranteed never to fail.\n\n::: {.incremental}\n\n- `f` is a terrible name for a function - use a descriptive name\n- keyword `function` used to define functions\n- `()` contain all the arguments separated by commas\n- `{}` contain the body of the function\n:::\n\n\n\n\n## Why write functions?\n\n::: {.incremental}\n\n- Reduce code duplication: Don't repeat yourself\n- Share between projects\n- Share with others\n- Promote better documentation\n- Easier to test\n- Easier to debug\n:::\n\n\n\n## Don't repeat yourself DRY\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\npenguins |> \n  filter(species == \"Gentoo\") |> \n  ggplot(aes(x = body_mass_g, y = bill_length_mm)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  labs(x = \"Body mass g\", y = \"Bill length mm\", title = \"Gentoo\")\n\npenguins |> \n  filter(species == \"Adelie\") |> \n  ggplot(aes(x = body_mass_g, y = bill_length_mm)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  labs(x = \"Body mass g\", y = \"Bill length mm\", title = \"Gentoo\")\n```\n:::\n\n## Identify arguments\n\nGeneral -- Specific functions\n\n- General - more arguments, more flexible, more complex\n- Specific - fewer arguments, less flexible, simpler\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\") |> \n  ggplot(aes(x = body_mass_g, y = bill_length_mm)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  labs(x = \"Body mass g\", y = \"Bill length mm\", title = \"Gentoo\")\n```\n:::\n\n## Sanity check inputs\n\nMake your functions idiot proof.\n\n::: {.cell}\n\n```{.r .cell-code}\narea_square <- function(side = 1) {\n  if (! is.numeric(side)) {\n    stop(\"side must be numeric\")\n  }\n  if (side <= 0) {\n    stop(\"side must be positive\")\n  }\n  side^2\n}  \narea_square(\"fish\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in area_square(\"fish\"): side must be numeric\n```\n:::\n\n```{.r .cell-code}\narea_square(-1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in area_square(-1): side must be positive\n```\n:::\n:::\n\n## Keep it Simple\n\nOne function - one job\n\n::: {.cell}\n\n```{.r .cell-code}\ncomplex <- function(arg1, arg2, ...) { # bad\n  # complex code to import data\n  # complex code to clean data\n  # complex code to model code\n  # complex code to plot model\n}\n```\n:::\n\nLarge complex function\n\n- difficult to understand\n- many arguments\n- difficult to test\n\n## Break into smaller functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Better\nimport_fun <- function(arg1) {\n  # complex code to import data\n}\n  \nclean_fun <- function(.data) {\n  # complex code to clean data\n}  \n\nmodel_fun <- function(.data_clean) {\n  # complex code to model code\n}\n\nplot_fun <- function(.data_clean) {\n  # complex code to plot model\n}    \n  \ncomplex <- function(arg1, arg2, ...) { \n  .data <- import_fun(arg1)\n  .data_clean <- clean_fun(.data)\n  mod <- model_fun(.data_clean)\n  plot <- plot_fun(.data_clean)\n  list(mod = mod, plot = plot)\n}  \n```\n:::\n\n\n\n## Functions using tidyverse\n\nTidyverse is fantastic for interactive analyses.\n\nBit complex with functions.\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_penguins <- function(.data, species) {\n  .data |> \n    filter(species == species)\n}\n  \nfilter_penguins(penguins, \"Gentoo\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 × 8\n   species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>              <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Torgersen           39.1          18.7               181        3750\n 2 Adelie  Torgersen           39.5          17.4               186        3800\n 3 Adelie  Torgersen           40.3          18                 195        3250\n 4 Adelie  Torgersen           NA            NA                  NA          NA\n 5 Adelie  Torgersen           36.7          19.3               193        3450\n 6 Adelie  Torgersen           39.3          20.6               190        3650\n 7 Adelie  Torgersen           38.9          17.8               181        3625\n 8 Adelie  Torgersen           39.2          19.6               195        4675\n 9 Adelie  Torgersen           34.1          18.1               193        3475\n10 Adelie  Torgersen           42            20.2               190        4250\n# ℹ 334 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n:::\n\n\nDo you need to use tidyverse?\n\n - reducing the number of dependencies is good\n\n## brace brace\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_penguins <- function(.data, species) {\n  .data |> \n    filter(species == {{species}})\n}\n  \nfilter_penguins(penguins, \"Gentoo\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 124 × 8\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Gentoo  Biscoe           46.1          13.2               211        4500\n 2 Gentoo  Biscoe           50            16.3               230        5700\n 3 Gentoo  Biscoe           48.7          14.1               210        4450\n 4 Gentoo  Biscoe           50            15.2               218        5700\n 5 Gentoo  Biscoe           47.6          14.5               215        5400\n 6 Gentoo  Biscoe           46.5          13.5               210        4550\n 7 Gentoo  Biscoe           45.4          14.6               211        4800\n 8 Gentoo  Biscoe           46.7          15.3               219        5200\n 9 Gentoo  Biscoe           43.3          13.4               209        4400\n10 Gentoo  Biscoe           46.8          15.4               215        5150\n# ℹ 114 more rows\n# ℹ 2 more variables: sex <fct>, year <int>\n```\n:::\n:::\n\n## And on the left hand side\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_penguins <- function(.data, column, value, new_col) {\n  .data |> \n    filter({{column}} == {{value}}) |> \n    mutate({{new_col}} := mean(body_mass_g)) # := instead of =\n  \n}\n  \nfilter_penguins(penguins, island, \"Dream\", island_mean)  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 124 × 9\n   species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n   <fct>   <fct>           <dbl>         <dbl>             <int>       <int>\n 1 Adelie  Dream            39.5          16.7               178        3250\n 2 Adelie  Dream            37.2          18.1               178        3900\n 3 Adelie  Dream            39.5          17.8               188        3300\n 4 Adelie  Dream            40.9          18.9               184        3900\n 5 Adelie  Dream            36.4          17                 195        3325\n 6 Adelie  Dream            39.2          21.1               196        4150\n 7 Adelie  Dream            38.8          20                 190        3950\n 8 Adelie  Dream            42.2          18.5               180        3550\n 9 Adelie  Dream            37.6          19.3               181        3300\n10 Adelie  Dream            39.8          19.1               184        4650\n# ℹ 114 more rows\n# ℹ 3 more variables: sex <fct>, year <int>, island_mean <dbl>\n```\n:::\n:::\n\n## Your turn\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  filter(species == \"Adelie\") |> \n  ggplot(aes(x = body_mass_g, y = bill_length_mm)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  labs(x = \"Body mass g\", y = \"Bill length mm\", title = \"Gentoo\")\n```\n:::\n\n\n# You cannot write functions without writing bugs.<br><br> That is the law\n\n## Bugs\n\n- Syntax error\n- Incorrect results\n- function throws unexpected error\n\n\n## Buggy code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuggy <- function(x){\n  x <- as.character(x)\n  log(x)\n}\nbuggy(1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in log(x): non-numeric argument to mathematical function\n```\n:::\n:::\n\n## Strategies for debugging 0\n\n- Read the error messages\n- Use `traceback()` to see where the error occurred\n- Use `options(error = recover)` to enter the debugger when an error occurs\n\n\n## Strategies for debugging 1\n\n- Add `print()` statements to see state of variables\n\n::: {.cell}\n\n```{.r .cell-code}\nbuggy <- function(x){\n  print(class(x))\n  x <- as.character(x)\n  print(class(x))\n  log(x)\n}\nbuggy(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n[1] \"character\"\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in log(x): non-numeric argument to mathematical function\n```\n:::\n:::\n\n## Strategies for debugging 2\n\n- Add `browser()` somewhere strategic\n\n::: {.cell}\n\n```{.r .cell-code}\nbuggy <- function(x){\n  browser()\n  x <- as.character(x)\n  log(x)\n}\nbuggy(1)\n```\n:::\n\nIn the debugger, use\n\n- `n` to step through the code\n- `c` to continue\n- `s` to step into a function\n- `Q` to quit\n\n\n## Strategies for debugging 3\n\nUse `debug` to automatically add `browser()`\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug(buggy)\nbuggy(1)\nundebug(buggy)\n\n# or\ndebugonce(buggy)\n```\n:::\n\n\n## Slow code\n\nR is normally fast enough, but when it isn't it isn't\n\nUse `tictoc` package to time code\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\ntic()\nSys.sleep(1)\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.007 sec elapsed\n```\n:::\n:::\n\n## `bench::mark()`\n\nUse `bench::mark()` to compare different implementations\n\n::: {.cell}\n\n```{.r .cell-code}\nbm <- bench::mark(\n  badloop = {x <- c(); for(i in 1:1000){x <- c(x, i^2)}; x},\n  goodloop = {x <- numeric(1000); for(i in 1:1000){x[i] <- i^2}; x},\n  map = purrr::map_dbl(1:1000, \\(i) i^2),\n  vectorised = (1:1000)^2\n)\nplot(bm)\n```\n\n::: {.cell-output-display}\n![](functions_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n## Profiler\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(profvis)\n\nf <- function() {\n  pause(0.1)\n  g()\n  h()\n}\ng <- function() {\n  pause(0.1)\n  h()\n}\nh <- function() {\n  pause(0.1)\n}\n\nprofvis(f())\n```\n:::\n\n\n## Cures for slow code\n\nReadability is more important than speed\n\n- Use vectorised code\n- parallelize code with `furrr` or `future` packages\n\n## More resources\n\n[profvis](https://profvis.r-lib.org/)\n\n[R for Data Science](https://r4ds.hadley.nz/functions.html) by Hadley Wickham and Garrett Grolemund\n\n[Advanced R](https://adv-r.hadley.nz/) by Hadley Wickham\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}